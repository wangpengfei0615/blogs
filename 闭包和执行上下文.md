![pic1](./image/pic1.png)

**闭包**  

​       &emsp;&emsp;闭包是一个从开始学Javascript就开始接触的一个词汇，但是闭包到底是什么，JavaScript标准中并没有明确的说明，其实闭包在计算机领域有三个不同的定义：  
​        &emsp;&emsp;1.编译原理：它是处理语法产生时的一个步骤  
​        &emsp;&emsp;2.在计算几何中：它表示包裹平面点集的凸多边形  
​        &emsp;&emsp;3.在编程语言领域:它代表着一种函数  
​         &emsp;&emsp;我们每天在说的闭包，指的大多都是第三种定义，这个概念第一次出现在1964年的《The Computer Journal》上，那里面把闭包定义为："带有一系列信息的表达式" 。所以我们可以这样去理解闭包：所谓闭包只是一个绑定了作用域的函数；它与普通函数的唯一区别是它绑定了它的作用域；  
​         &emsp;&emsp;在古典定义中，闭包包括两个部分：   
​         &emsp;&emsp;1.环境部分(包括环境和标识符列表)  
​         &emsp;&emsp;2.表达式部分  
​         &emsp;&emsp;但是我们把目光切回到JavaScript，JavaScript中的函数完全符合闭包的定义，它的环境部分是其词法作用环境，它的表示符是函数中未曾声明过的变量，它的表达式部分是函数体；所以由于上述的分析，闭包并不是所谓的它在JavaScrip执行上下文或者作用域的概念，其实中对应的概念就是JavaScript中的函数；

**执行上下文**
       &emsp;&emsp;Javascript中我们是一段一段去执行代码，比如全局代码块，函数代码块，eval代码块，我们把一段段代码块，执行所需的所有信息叫做执行上下文。  
​       &emsp;&emsp;ES3中执行上下文分为三个部分：  
​       &emsp;&emsp;1.scope:作用域   
​       &emsp;&emsp;2.variable object: 变量对象  
​       &emsp;&emsp;3.this value :this 的值   
​       &emsp;&emsp;ES5中把其命名方式更改成如下：  
​       &emsp;&emsp;1.lexical environment词法环境 - 当获取变量的时候使用  
​       &emsp;&emsp;2.variable environment变量环境 -当变量声明的时候使用  
​       &emsp;&emsp;3.this value :this 的值     
	   &emsp;&emsp;在ES2018中，执行上下文又变成了这个样子，被归入 lexical environment，但是增加了不少内容：    
​	   &emsp;&emsp;1.lexical environment词法环境 - 当获取变量的时候使用    
​       &emsp;&emsp;2.variable environment变量环境 -当变量声明的时候使用    
​	   &emsp;&emsp;3. code evaluation state :用于恢复代码的执行位置      
​	   &emsp;&emsp;4.Function：执行的任务是函数时候使用，表示正在执行的函数    
​	   &emsp;&emsp;5.ScriptOrModule: 执行的任务是脚本或者模块的时候使用，表示正在执行的代码   
​	   &emsp;&emsp;6.Realm：使用的基础库和内置对象实例    
​	   &emsp;&emsp;7.仅生成器上下文有这个属性，表示当前的生成器	   
       我们可以看出来
  
       
       &emsp;&emsp;由于我们代码中的代码块有很多，我们需要依靠执行上下文栈去管理这些执行上下文；         
```

var scope = "global"     
function functionScope (scope) {    
var scope = "local"    
function fn2Scpoe() {  
 return scope  
 }
return fn2Scpoe()
}
functionScope('scope')
``` 

&emsp;&emsp;因为被被称为执行上下文栈，所以我们是以栈这种结构去存放我们的执行上下文，我们都知道栈这种数据结构存取数据的时候会严格按照
先进后出的规则；    

&emsp;&emsp;首先 我们在执行这段代码的时候获取到了全局上下文（Global code），所以我们就把全局上线文去推入执行上下文栈，      

```

/* ESC 是模拟的执行上下文栈 */  
ESC = [
  globalContext, // 一开始只有全局上下文
]
```

&emsp;&emsp;然后我们继续去执行代码块,当执行到函数functionScope（'scope'）的时候，我们创建了functionScope函数的执行上下文
并将其压入我们的执行上下文栈，因此我们的执行上下文栈变成了这样：  
```

ESC = [
  functionScope, // functionScope 被压进了执行上下文栈
  globalContext, // 一开始只有全局上下文
]
```
最后在执行fn2Scpoe()的时候在执行上文栈中压入fn2Scpoe的执行上下文； 
``` 
ESC = [
   fn2Scpoe，  
  functionScope, 
  globalContext, 
]
```


